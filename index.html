<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real-time Instagram-style Filters (Canvas)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#0b0d10; color:#eaeef3; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display: grid; gap: 14px; }
    .top { display:flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { background:#12161c; border:1px solid #1f2630; border-radius: 14px; padding: 14px; }
    canvas { width: 100%; height: auto; border-radius: 14px; background:#0d1015; }
    label { display:flex; gap: 10px; align-items:center; justify-content: space-between; margin: 10px 0; }
    input[type="range"] { width: 62%; }
    select, input[type="file"], button { background:#0f141b; color:#eaeef3; border:1px solid #263041; border-radius: 10px; padding: 8px 10px; }
    button { cursor:pointer; }
    .grid { display:grid; grid-template-columns: 1.3fr 0.7fr; gap: 14px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } input[type="range"]{ width: 60%; } }
    .hint { color:#a8b3c5; font-size: 13px; line-height: 1.4; margin-top: 8px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .badge { font-size:12px; color:#a8b3c5; padding:4px 8px; border:1px solid #263041; border-radius:999px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card top">
      <div class="row">
        <input id="file" type="file" accept="image/*" />
        <select id="preset"></select>
        <button id="reset">Reset</button>
        <button id="save">Save PNG</button>
      </div>
      <span class="badge" id="fps">fps: -</span>
      <div class="hint">
        Tip: 这版用 Canvas 逐像素处理（CPU）。图片太大时会慢；想更快可用 WebGL shader（需要我也可以给你一版）。
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <canvas id="cv"></canvas>
      </div>

      <div class="card">
        <label>
          Strength
          <input id="strength" type="range" min="0" max="1" step="0.01" value="0.85" />
          <span id="strengthV">0.85</span>
        </label>
        <label>
          Exposure
          <input id="exposure" type="range" min="-0.6" max="0.6" step="0.01" value="0.05" />
          <span id="exposureV">0.05</span>
        </label>
        <label>
          Contrast
          <input id="contrast" type="range" min="0.6" max="1.6" step="0.01" value="1.10" />
          <span id="contrastV">1.10</span>
        </label>
        <label>
          Saturation
          <input id="saturation" type="range" min="0" max="2" step="0.01" value="1.15" />
          <span id="saturationV">1.15</span>
        </label>
        <label>
          Temperature
          <input id="temp" type="range" min="-0.3" max="0.3" step="0.01" value="0.06" />
          <span id="tempV">0.06</span>
        </label>
        <label>
          Fade (Matte)
          <input id="fade" type="range" min="0" max="0.5" step="0.01" value="0.12" />
          <span id="fadeV">0.12</span>
        </label>
        <label>
          Vignette
          <input id="vignette" type="range" min="0" max="0.8" step="0.01" value="0.22" />
          <span id="vignetteV">0.22</span>
        </label>
        <label>
          Grain
          <input id="grain" type="range" min="0" max="0.5" step="0.01" value="0.10" />
          <span id="grainV">0.10</span>
        </label>

        <div class="hint">
          Preset 会自动把这些参数设置到一套“类似 IG 风格”的配方，你也可以再手动微调。
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // Utilities
  // -----------------------------
  const clamp01 = (x) => Math.min(1, Math.max(0, x));
  const lerp = (a,b,t) => a + (b-a)*t;

  function rgbToHsl(r,g,b){
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    let h=0, s=0;
    const l = (max+min)/2;
    if(max !== min){
      const d = max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h = (g-b)/d + (g<b ? 6 : 0); break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h /= 6;
    }
    return [h,s,l];
  }
  function hslToRgb(h,s,l){
    function hue2rgb(p,q,t){
      if(t<0) t+=1; if(t>1) t-=1;
      if(t<1/6) return p+(q-p)*6*t;
      if(t<1/2) return q;
      if(t<2/3) return p+(q-p)*(2/3 - t)*6;
      return p;
    }
    let r,g,b;
    if(s===0){ r=g=b=l; }
    else{
      const q = l<0.5 ? l*(1+s) : l+s-l*s;
      const p = 2*l-q;
      r = hue2rgb(p,q,h+1/3);
      g = hue2rgb(p,q,h);
      b = hue2rgb(p,q,h-1/3);
    }
    return [r,g,b];
  }

  // S-curve-ish contrast around 0.5
  function applyContrast(x, c){
    return clamp01((x - 0.5) * c + 0.5);
  }

  // "Fade / matte" lifts shadows and slightly compresses highlights
  function applyFade(x, amount){
    // amount 0..0.5
    const a = amount;
    // Lift blacks
    let y = x*(1 - 0.25*a) + 0.08*a;
    // Compress highlights a bit
    y = lerp(y, Math.pow(y, 0.9), 0.35*a);
    return clamp01(y);
  }

  // Temp shift: warm -> raise R, lower B (simple)
  function applyTemperature(r,g,b, t){
    // t -0.3..0.3
    const rr = clamp01(r * (1 + t));
    const bb = clamp01(b * (1 - t));
    return [rr,g,bb];
  }

  function vignetteFactor(x,y,w,h, strength){
    if(strength <= 0) return 1;
    const nx = (x/(w-1))*2-1;
    const ny = (y/(h-1))*2-1;
    const d = Math.sqrt(nx*nx + ny*ny);
    // smooth falloff
    const v = 1 - strength * Math.pow(Math.min(1, d), 1.7);
    return Math.max(0, v);
  }

  // Deterministic pseudo-random for grain
  function noise2D(x,y,seed){
    // cheap hash
    let n = x*374761393 + y*668265263 + seed*1442695041;
    n = (n ^ (n >> 13)) * 1274126177;
    n = n ^ (n >> 16);
    // [0,1)
    return (n >>> 0) / 4294967296;
  }

  // -----------------------------
  // Presets (Instagram-ish approximations)
  // -----------------------------
  const PRESETS = {
    "Clarendon-ish": { strength:0.85, exposure:0.03, contrast:1.22, saturation:1.18, temp:0.05, fade:0.06, vignette:0.18, grain:0.06 },
    "Gingham-ish":   { strength:0.90, exposure:0.06, contrast:0.98, saturation:0.92, temp:0.02, fade:0.20, vignette:0.15, grain:0.07 },
    "Juno-ish":      { strength:0.85, exposure:0.04, contrast:1.10, saturation:1.28, temp:0.10, fade:0.08, vignette:0.18, grain:0.07 },
    "Lark-ish":      { strength:0.85, exposure:0.08, contrast:1.05, saturation:1.06, temp:-0.02, fade:0.10, vignette:0.12, grain:0.05 },
    "Valencia-ish":  { strength:0.90, exposure:0.05, contrast:0.96, saturation:1.10, temp:0.12, fade:0.16, vignette:0.10, grain:0.06 },
    "Lo-Fi-ish":     { strength:0.90, exposure:0.02, contrast:1.40, saturation:1.25, temp:0.04, fade:0.04, vignette:0.38, grain:0.08 },
    "Inkwell-ish(BW)":{strength:1.00, exposure:0.02, contrast:1.35, saturation:0.00, temp:0.00, fade:0.10, vignette:0.22, grain:0.08 },
    "X-Pro-ish":     { strength:0.90, exposure:0.00, contrast:1.25, saturation:1.12, temp:0.06, fade:0.06, vignette:0.30, grain:0.10 },
  };

  // -----------------------------
  // UI wiring
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const canvas = $("cv");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  const ui = {
    file: $("file"),
    preset: $("preset"),
    reset: $("reset"),
    save: $("save"),
    fps: $("fps"),
    strength: $("strength"),
    exposure: $("exposure"),
    contrast: $("contrast"),
    saturation: $("saturation"),
    temp: $("temp"),
    fade: $("fade"),
    vignette: $("vignette"),
    grain: $("grain"),
  };

  const uiVals = {
    strengthV: $("strengthV"),
    exposureV: $("exposureV"),
    contrastV: $("contrastV"),
    saturationV: $("saturationV"),
    tempV: $("tempV"),
    fadeV: $("fadeV"),
    vignetteV: $("vignetteV"),
    grainV: $("grainV"),
  };

  function setSlider(name, value){
    ui[name].value = value;
    uiVals[name+"V"].textContent = (+value).toFixed(2);
  }
  function getParams(){
    return {
      strength: +ui.strength.value,
      exposure: +ui.exposure.value,
      contrast: +ui.contrast.value,
      saturation: +ui.saturation.value,
      temp: +ui.temp.value,
      fade: +ui.fade.value,
      vignette: +ui.vignette.value,
      grain: +ui.grain.value,
    };
  }
  function applyPreset(p){
    for(const k of Object.keys(p)){
      if(ui[k]) setSlider(k, p[k]);
    }
    requestRender();
  }

  // populate presets
  for(const name of Object.keys(PRESETS)){
    const opt = document.createElement("option");
    opt.value = name; opt.textContent = name;
    ui.preset.appendChild(opt);
  }
  ui.preset.value = "Clarendon-ish";

  // -----------------------------
  // Image loading + scaling
  // -----------------------------
  const img = new Image();
  img.crossOrigin = "anonymous";

  // default: generate a sample gradient image if user doesn't upload
  function drawPlaceholder(){
    const w = 1200, h = 800;
    canvas.width = w; canvas.height = h;
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0, "#2b5876");
    g.addColorStop(0.45, "#4e4376");
    g.addColorStop(1, "#f7971e");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "48px system-ui";
    ctx.fillText("Upload an image to test filters", 70, 120);
    ctx.font = "22px system-ui";
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.fillText("This is a placeholder canvas.", 70, 170);
    originalImageData = ctx.getImageData(0,0,w,h);
    requestRender();
  }

  let originalImageData = null;

  function fitToCanvas(image, maxW=1400){
    // scale down for speed
    const ratio = image.naturalWidth / image.naturalHeight;
    let w = Math.min(maxW, image.naturalWidth);
    let h = Math.round(w / ratio);
    if(h > 1000){
      h = 1000;
      w = Math.round(h * ratio);
    }
    canvas.width = w;
    canvas.height = h;
    ctx.drawImage(image, 0, 0, w, h);
    originalImageData = ctx.getImageData(0, 0, w, h);
  }

  ui.file.addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    img.onload = () => {
      fitToCanvas(img);
      URL.revokeObjectURL(url);
      requestRender();
    };
    img.src = url;
  });

  // -----------------------------
  // Rendering (real-time)
  // -----------------------------
  let raf = 0;
  let last = performance.now();
  let frames = 0;

  function requestRender(){
    if(raf) return;
    raf = requestAnimationFrame(render);
  }

  function render(now){
    raf = 0;
    if(!originalImageData) return;

    const t0 = performance.now();
    const params = getParams();

    // Read original pixels
    const src = originalImageData.data;
    const w = originalImageData.width;
    const h = originalImageData.height;
    const out = ctx.createImageData(w, h);
    const dst = out.data;

    const seed = 1337;
    const grainAmt = params.grain;
    const vigAmt = params.vignette;
    const strength = params.strength;

    // We will compute a "cooked" version then blend with original by strength
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const r0 = src[i]/255, g0 = src[i+1]/255, b0 = src[i+2]/255;

        // --- Cooked pipeline ---
        let r=r0, g=g0, b=b0;

        // Exposure (simple add)
        const ex = params.exposure;
        r = clamp01(r + ex);
        g = clamp01(g + ex);
        b = clamp01(b + ex);

        // Contrast
        r = applyContrast(r, params.contrast);
        g = applyContrast(g, params.contrast);
        b = applyContrast(b, params.contrast);

        // Saturation in HSL
        let [hh, ss, ll] = rgbToHsl(r,g,b);
        ss = clamp01(ss * params.saturation);
        [r,g,b] = hslToRgb(hh, ss, ll);

        // Temperature
        [r,g,b] = applyTemperature(r,g,b, params.temp);

        // Fade / matte
        r = applyFade(r, params.fade);
        g = applyFade(g, params.fade);
        b = applyFade(b, params.fade);

        // Vignette
        const v = vignetteFactor(x,y,w,h, vigAmt);
        r *= v; g *= v; b *= v;

        // Grain
        if(grainAmt > 0){
          const n = noise2D(x,y,seed) * 2 - 1; // [-1,1]
          // midtone-weighted grain
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          const midW = 1 - Math.abs(lum - 0.5)*2; // 0..1
          const gn = n * (0.03 + 0.12*grainAmt) * midW;
          r = clamp01(r + gn);
          g = clamp01(g + gn);
          b = clamp01(b + gn);
        }

        // --- Blend with original by strength ---
        r = lerp(r0, r, strength);
        g = lerp(g0, g, strength);
        b = lerp(b0, b, strength);

        dst[i]   = (r*255)|0;
        dst[i+1] = (g*255)|0;
        dst[i+2] = (b*255)|0;
        dst[i+3] = 255;
      }
    }

    ctx.putImageData(out, 0, 0);

    // fps counter
    frames++;
    if(now - last >= 500){
      const fps = Math.round((frames*1000)/(now-last));
      ui.fps.textContent = `fps: ${fps}  | render: ${Math.round(performance.now()-t0)}ms`;
      frames = 0; last = now;
    }
  }

  // Slider updates
  for(const k of ["strength","exposure","contrast","saturation","temp","fade","vignette","grain"]){
    ui[k].addEventListener("input", () => {
      uiVals[k+"V"].textContent = (+ui[k].value).toFixed(2);
      requestRender();
    });
  }

  ui.preset.addEventListener("change", () => applyPreset(PRESETS[ui.preset.value]));
  ui.reset.addEventListener("click", () => applyPreset(PRESETS["Clarendon-ish"]));

  ui.save.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = "filtered.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  });

  // init
  applyPreset(PRESETS["Clarendon-ish"]);
  drawPlaceholder();
})();
</script>
</body>
</html>

